\chapter{Metodologia} \label{cap:ferramentas}

O texto a seguir abordará o problema proposto por esse trabalho, e logo em seguida, será apresentado um modelo de resolução para rotulação de dados utilizando dois algoritmos supervisionados baseados em paradigmas simbólico e estatístico . O objetivo ao final deste capítulo é poder resolucionar o problema de rotulação, com utilização de dois algoritmos, e atribuir a qualquer outro pesquisador todo o conhecimento necessário para replicar este trabalho através das informações produzidas aqui.

\section{Considerações do Problema}\label{cap:ferramentas:sec:considproblema}

A abordagem do problema referente a essa proposta de mestrado segue uma linha já pequisada por \citeonline{LOPES2014}, que seria o \textbf{Problema de Rotulação}. Esse conceito, rotulação de dados,  já é estudado na literatura na área de aprendizagem não-supervisionada, subseção \ref{ssec:aprendNSup}, onde é comum os algoritmos lidarem com os agrupamentos dos dados, e a criação de clusters a partir dos graus de  similaridade entre os elementos.

Muitas pesquisas realizadas na área de rotulação fazem referência a classificação dos dados e não da rotulação, nos termos desse trabalho. Ao agrupar um conjunto de elementos por um derterminado critério, esta havendo uma classificação desses elementos de mesma similaridade, mas pouco se sabe, qual é a compreensão desses grupos já classificados. 

A importância do rótulo em um cluster é transparecer a compreensão do cluster formado, visto que, uma vez os clusters já agrupados não fica claro o critério de criação desses grupos. Para o espectador é interessante existir um rótulo de um grupo oferecendo elementos que possam ajudar em alguma tomada de decisão em razão de seu significado (rótulo).

A criação do rótulo é a escolha de uma tupla \textbf{atributo} e \textbf{faixa de valor}, onde o atributo possui  o maior  valor de correlacionamento entre os outros atributos. E a faixa escolhida é aquela que  mais se repete desse atributo rótulo. Podendo o cluster ter mais de um rótulo contendo a tupla atributo e faixa.

Essa faixa, é um intervalo de valor definido pela discretização seção \ref{cap:refTeor:sec:discret}, onde o intervalo escolhido, seria a faixa que representa os valores que se repetem com a maior frequência no atributo. A exemplo disso, tem-se um vetor de elementos já discretizados, ${\vec{a}_i=\{1,1,1,2,2,2,2,3,3\}}$, onde $i\leqslant m$ e ${(\vec{a})}$ representa todos os elementos da coluna representada pelo atributo  ${(a)}$. Neste vetor o valor que mais se repete é o número 2, então, a \textbf{faixa 2} do atributo rótulo é a escolhida para compor o rótulo.

O Problema de Rotulação é formalmente definido como segue abaixo:
%\newtheorem{teorema}{Definição}
    \begin{teorema}
    Dado um conjunto de clusters ${C=\{c_1,...,c_k | K \geqslant 1\} }$, de modo que cada cluster contém um conjunto de elementos ${c_i=\{\vec{e}_1,..,\vec{e}_{n^{(c_i)}}|n^{(c_i)} \geqslant 1 \}}$ que podem ser representados por um vetor de atributos definidos em ${\mathbb{R}^m }$ e expresso por ${ \vec{e}^{c_i}=(a_1,..,a_m)  }$ e ainda que  com ${ c_i \cap c_{i'}=0 }$ com ${ 1 \leqslant i, i \leqslant K  }$ e ${ i \neq i' }$.
        \footnotemark 
        \footnotetext{Adaptada de \cite{LOPES2014}}
        \begin{itemize}[noitemsep]
            \item ${K}$ é o número de clusters;
            \item ${a}$ é o atributo
            \item ${c_i}$ é o i-ésimo cluster qualquer;
            \item ${n^{c_i}}$ é o número de elementos do cluster ${c_i}$;
            \item ${\vec{e}_{n^{(c_i)}}}$ se refere ao j-ésimo elemento pertencente ao cluster ${c_i}$;
            \item ${m}$ é a dimensão do problema;
        \end{itemize}
    \label{teo:problema}
    \end{teorema}

%\afterpage{
%    \begin{quotation}

%        \textit{ Dado um conjunto de clusters ${C=\{c_1,...,c_k | K \geqslant 1\} }$, de modo que cada cluster contém um conjunto de elementos ${c_i=\{\vec{e}_1,..,\vec{e}_{n^{(c_i)}}|n^{(c_i)} \geqslant 1 \}}$ que podem ser representados por um vetor de atributos definidos em ${\mathbb{R}^m }$ e expresso por ${ \vec{e}^{c_i}=(a_1,..,a_m)  }$ e ainda que  com ${ c_i \cap c_{i'}=\{0\} }$ com ${ 1 \leqslant i, i \leqslant K  }$ e ${ i \neq i' }$.
%        }\footnotemark 

%        \footnotetext{Extraída de \cite{Lopes}}
%        \begin{itemize}[noitemsep]
%            \item ${K}$ é o número de clusters;
%            \item ${c_i}$ é o i-ésimo cluster qualquer;
%            \item ${n^{c_i}}$ é o número de elementos do cluster ${c_i}$;
%            \item ${\vec{e}_{n^{(c_i)}}}$ se refere ao j-ésimo elemento pertencente ao cluster ${c_i}$;
%            \item ${m}$ é a dimensão do problema;
%        \end{itemize}
%    \end{quotation}
    %\footnotetext{Extraída de \cite{Lopes}}
%}

\section{O Modelo de Resolução}\label{cap:ferramentas:sec:modeloresolucao}

A partir da definição do problema - \textit{Definição ~\ref{teo:problema}} - um estudo científico foi desenvolvido nesta pesquisa, a fim de provar, que é possível a realização de rotulação de dados com dois algoritmos supervisionados de paradigmas diferentes: Naive Bayes e CART.


Este modelo de resolução consiste em apresentar como saída um conjunto de rótulos, onde cada rótulo específico é dado por um conjunto de pares de valores, atributo e seus respectivos intevalos, gerados a partir das frequências dos valores repetidos neste intervalo. Segue \textit{Definição ~\ref{teo:resolucao}} formalizando a saída do modelo:
%\newtheorem{teorema}{Definição}
    \begin{teorema}
    Dado um conjunto de rótulos ${ R=\{ r_{c1},...,r_{ck} \} }$, no qual cada rótulo específico é dados por um conjunto de pares de valores, tem como saída um vetor com atributo e seu respectivo intervalo, ${ r_{ci}=\{ (a_1,[p_1,q_1]),...,(a_{m^{(c_i)}}, ]p_{m^{(c_i)}},q_{m^{(c_i)}}]) \} }$ capaz de melhor expressar o cluster ${c_i}$.
        \footnotemark 
        \footnotetext{Adaptada de \cite{LOPES2014}}
        \begin{itemize}[noitemsep]
            \item ${k}$ número de rótulos;
            \item ${R}$ representa o conjunto de rótulos na saída do modelo;
            \item ${a}$ é o atributo
            \item ${c_i}$ é o i-ésimo cluster;
            \item ${r_{c_i}}$ é o rótulo referente ao cluster ${c_i}$;
            \item ${]p_{m^{(c_i)}},q_{m^{(c_i)}}]}$ representa o intervalo de valores do atributo ${a_{m^{(c_i)}} }$, onde ${ p_{m^{(c_i)}} }$  é o limite inferior e ${ q_{m^{(c_i)}} }$ é o limite superior;
            \item ${m}$ é a dimensão do problema;
        \end{itemize}
    \label{teo:resolucao}
    \end{teorema}

Como apresentado na seção \ref{cap:refTeor:sec:trabcorrel}, o autor \citeonline{LOPES2014} foca em rotulação automática de grupos utilizando a estratégia de aprendizagem de máquina supervisionada, com paradigma conexionista, para provar seu trabalho. Porém, nesta pesquisa foi aplicado no modelo de resolução  dois algoritmos com paradigmas de aprendizado diferente do que já havia sido testado anteriormente, provando que é possível fazer rotulação de dados com  algoritmos supervisionados com paradigmas simbólico e probabilístico, CART e Naive Bayes respectivamente.


\begin{figure}[h!]
        \centering
        \includegraphics[scale=0.7]{figs/modeloResolucao.png}
        \caption{Modelo de Resolução Proposto} \label{fig:modeloresolucao}
\end{figure}

O modelo (figura \ref{fig:modeloresolucao}) inicialmente mostra a Base de Dados  já classificada, lembrando que esta pesquisa não tem o cunho de utilizar algoritmos para classificação dos dados, pois o cerne desta é conceder ao grupo um significado (rotulação). Essa base  conterá  valores contínuos, contudo, conforme modelo será necessário aplicar o método de discretização (I).

Uma vez com a base discretizada ocorre a divisão dos clusters já classificados de acordo com a própria base de dados\footnote{UCI - Machine Learning Repository. http://archive.ics.uci.edu/ml/ }. Isso é o funcionamento do fluxo (a), que nada mais é do que a separação da base em grupos já classificados. 

No passo (II) serão executados os algoritmos de aprendizagem supervisionados, já visto nas subseções \ref{cap:refTeor:sssec:cart} e \ref{cap:refTeor:sssec:nbayes}. Essa etapa utiliza uma técnica demonstrada na seção  \ref{cap:ferramentas:sec:tecnica} sendo uma das mais importantes do método. A quantidade de vezes que o algoritmo supervisionado é aplicado - dimensão ${m}$ da Definição \ref{teo:problema} -  irá ser a mesma do número de atributos do conjunto de dados. Utilizando a figura \ref{fig:tecnicamodelocomp} como exemplo, o algoritmo supervisionado seria executado três vezes, sendo essa quantidade igual ao número de atributos: \textbf{atr1, atr2} e \textbf{atr3}. 

\begin{figure}[h!]
        \centering
        \includegraphics[scale=0.7]{figs/tecnicamodeloComp.png}
        \caption{Exemplo da técnica aplicada ao atr1, atr2 e atr3 sendo classes } \label{fig:tecnicamodelocomp}
\end{figure}

Seguindo para o processo (III) acontecerá a escolha do(s) atributo(s) mais relevante(s), esta seleção será feita a partir de uma matriz (\textbf{Atributos Importantes}) criada pela implementação dos algoritmos supervisionados utilizando a técnica de correlação entre atributos seção (\ref{cap:ferramentas:sec:tecnica}), junto com o valor mais frequente desse(s) atributo(s). Após essa etapa é criado um conjunto de rotulos para cada clusters. O fluxo (b) será utilizado enquanto houver outros algoritmos para serem executados.

\section{Técnica de Correlação entre Atributos }\label{cap:ferramentas:sec:tecnica}

Essa técnica\footnote{Desenvolvida também por \cite{LOPES2014}} possui um grau de processamento diretamente proporcional a quantidade de características expressa na base de dados definido em ${R^m}$. Ela implica em utilizar todos os atributos, menos o definido como classe, para fazer uma correlação entre eles junto ao algoritmo.


Utilizando como exemplo uma base com os seguintes atributos: \textbf{atr1, atr2, atr3 e classe}. O atributo classe é retirado, e a cada iteração, um atributo será definido como a nova classe, portanto retirando a classe, a base possui três atributos então o algoritmo será aplicado três vezes. Em um primeiro processamento de três, o primeiro atributo \textbf{atr1} se torna classe e executado com os outros dois atributos restantes com um algoritmo supervisionado, figura \ref{fig:tecnicamodelo}.

\begin{figure}[h!]
        \centering
        \includegraphics[scale=0.7]{figs/tecnicamodelo.png}
        \caption{Exemplo da técnica aplicada ao atr1 sendo classes } \label{fig:tecnicamodelo}
\end{figure}

O resultado da correlação entre os atributos \textbf{atr2, atr3} em relação ao \textbf{atr1} (figura \ref{fig:tecnicamodelo}) é armazanado em uma matriz, denominada de \textbf{Atributos Importantes}, de acordo com figura \ref{fig:modeloresolucao}. Por conseguinte é realizado a aplicação do algoritmo com \textbf{atr2} sendo classe, e assim sucessivamente até o último atributo (\textbf{atr3}). Essa etapa só é finalizada quando todos os atributos tiverem a chance de ser classe, figura \ref{fig:tecnicamodelocomp}, e armazenado seus valores em porcentagem na tabela. No final uma tabela será formada pelos valores em porcentagem  da correlação entre eles.



\section{Exemplo} \label{cap:ferramentas:sec:exebasemodfic}

Para melhor esclarecer as etapas da figura \ref{fig:modeloresolucao}, será utilizado  a tabela \ref{tab:bdm} como exemplo no processo de modelo de resolução proposto nesta pesquisa. Essa tabela é composta por cinquenta linhas, três atributos e um atributo classe. Logo na primeira coluna da tabela, possui o índice da linha da tabela identificando cada registro e outros campos são atributos que definem características do registro identificado pelo índice da primeira coluna, e na quinta coluna a classe de cada registro.

\begin{table}[!ht]
\centering
\caption{Base de Dados Modelo}
\label{tab:bdm}
\begin{tabular}{|lllll|}
\hline 
  & atr1 & atr2 & atr3 & classe \\ \hline
1 & 2.08 & 92.11 & 22.07 & 2 \\ \hline
2 & 1.26 & 85.03 & 20.45 & 1 \\ \hline
3 & 2.00 & 108.36 & 22.68 & 2 \\ \hline
4 & 1.74 & 43.78 & 18.72 & 3 \\ \hline
5 & 1.82 & 100.20 & 23.09 & 2 \\ \hline
6 & 1.43 & 77.59 & 21.80 & 1 \\ \hline
7 & 1.53 & 44.01 & 20.98 & 3 \\ \hline
8 & 1.14 & 107.77 & 18.99 & 2 \\ \hline
9 & 1.97 & 98.00 & 22.32 & 2 \\ \hline
10 & 1.50 & 39.67 & 21.78 & 3 \\ \hline
11 & 1.74 & 55.86 & 20.31 & 3 \\ \hline
12 & 1.80 & 65.72 & 19.62 & 1 \\ \hline
13 & 1.33 & 82.01 & 19.82 & 1 \\ \hline
14 & 1.66 & 103.93 & 21.10 & 2 \\ \hline
15 & 1.42 & 66.14 & 21.61 & 1 \\ \hline
16 & 1.87 & 88.36 & 22.45 & 2 \\ \hline
17 & 1.11 & 107.82 & 19.32 & 2 \\ \hline
18 & 2.08 & 67.66 & 20.74 & 1 \\ \hline
19 & 1.85 & 82.65 & 20.35 & 1 \\ \hline
20 & 1.04 & 102.62 & 19.46 & 2 \\ \hline
21 & 1.97 & 100.37 & 21.94 & 2 \\ \hline
22 & 1.95 & 45.70 & 22.10 & 3 \\ \hline
23 & 1.77 & 50.04 & 20.16 & 3 \\ \hline
24 & 1.97 & 81.57 & 19.83 & 1 \\ \hline
25 & 1.52 & 93.13 & 20.61 & 2 \\ \hline
  \end{tabular}
  \begin{tabular}{ |lllll| }
   
\hline
  & atr1 & atr2 & atr3 & classe \\ \hline
26 & 1.42 & 53.51 & 19.64 & 3 \\ \hline
27 & 1.12 & 62.71 & 19.07 & 1 \\ \hline
28 & 2.09 & 60.58 & 20.20 & 1 \\ \hline
29 & 1.95 & 69.23 & 19.68 & 1 \\ \hline
30 & 1.03 & 47.81 & 19.47 & 3 \\ \hline
31 & 1.75 & 90.92 & 21.39 & 2 \\ \hline
32 & 1.72 & 42.35 & 22.89 & 3 \\ \hline
33 & 1.47 & 101.77 & 19.20 & 2 \\ \hline
34 & 1.53 & 41.16 & 22.67 & 3 \\ \hline
35 & 1.44 & 93.61 & 21.03 & 2 \\ \hline
36 & 1.51 & 98.65 & 19.24 & 2 \\ \hline
37 & 1.06 & 68.82 & 21.68 & 1 \\ \hline
38 & 1.48 & 80.40 & 21.43 & 1 \\ \hline
39 & 1.14 & 61.59 & 19.90 & 1 \\ \hline
40 & 1.08 & 91.93 & 20.81 & 2 \\ \hline
41 & 1.62 & 79.21 & 18.43 & 1 \\ \hline
42 & 1.68 & 80.87 & 18.42 & 1 \\ \hline
43 & 1.81 & 98.24 & 22.13 & 2 \\ \hline
44 & 1.30 & 69.27 & 18.83 & 1 \\ \hline
45 & 1.80 & 101.21 & 21.61 & 2 \\ \hline
46 & 1.79 & 72.02 & 22.02 & 1 \\ \hline
47 & 1.56 & 81.71 & 22.10 & 1 \\ \hline
48 & 1.98 & 77.16 & 21.71 & 1 \\ \hline
49 & 1.86 & 89.12 & 22.84 & 2 \\ \hline
50 & 1.55 & 76.01 & 19.74 & 1 \\ \hline
\end{tabular}
\end{table}

Seguindo a definição \ref{teo:problema} um elemento é expresso por um vetor  de dimensão ${m}$, com tamanho igual ao número de atributos. Um exemplo do elemento 2 da tabela \ref{tab:bdm}, pode ser representado por ${\vec{e}_{2}=(1.26,85.03, 20.45)}$.

\subsection{Processo (I) - Discretização} \label{cap:ferramentas:ssec:disc}

Segundo \citeonline{Catlett2006b,Hwang2002} através de resultados expermentais, na conversão em atributos discretos ordenados de vários domínios constatou, que a mudança de representação da informação na maioria das vezes  pode aumentar a acurácia do sistema de aprendizado. Dessa maneira a etapa de discretização ganha um papel importante no modelo, e também no processo de Rotulação (III), pois é utilizada uma inferência na faixa discretizada para encontrar o intervalo na faixa.

Utilizando como exemplo a tabela \ref{tab:bdm} será utilizada a técnica de discretização por frequências iguais - EFD - e divisão de números de faixas igual a R=3. Na figura\footnote{Figura adaptada de \cite{LOPES2014}} \ref{fig:EFD_R_3} poderá ser vizualizado como é feita a discretização.

 \begin{figure}[!h]
    \centering
    \subfloat[Discretização em atr1]{
        \includegraphics[scale=0.8]{figs/discretizacaoEFD_R_3_atr1.png}
        \label{fig:EFD_R_3:efd:atr1} }
    
    \subfloat[Discretização em atr2]{
        \includegraphics[scale=0.8]{figs/discretizacaoEFD_R_3_atr2.png}
        \label{fig:EFD_R_3:efd:atr2} }
    
    \subfloat[Discretização em atr3]{
        \includegraphics[scale=0.8]{figs/discretizacaoEFD_R_3_atr3.png}
        \label{fig:EFD_R_3:efd:atr2} } 
    
    \caption{Discretização de atributos utilizando EFD com R = 3} \label{fig:EFD_R_3}
        
        %\includegraphics[scale=0.4]{figs/grafB.png}
        %\caption{Polinômio Superajustado} \label{grafB}
\end{figure}

Através da figura \ref{fig:EFD_R_3} fica claro o conteúdo da faixa 1, contendo o valor inicial, 1(um), até o primeiro ponto de corte. Na faixa 2, o valor inicial é o primeiro número após o primeiro ponto de corte (término da faixa 1) até o segundo ponto de corte, incluindo o próprio ponto de corte. E na faixa 3 contém todos  valores a partir do segundo ponto de corte.

\begin{table}[!ht]
\centering
\caption{Base de Dados Modelo Discretizada}
\label{tab:bdmd}
\begin{tabular}{|lllll|}
\hline 
  & atr1 & atr2 & atr3 & classe \\ \hline
1	&	3	&	3	&	3	&	2	\\	\hline
2	&	1	&	2	&	2	&	1	\\	\hline
3	&	3	&	3	&	3	&	2	\\	\hline
4	&	2	&	1	&	1	&	3	\\	\hline
5	&	3	&	3	&	3	&	2	\\	\hline
6	&	1	&	2	&	3	&	1	\\	\hline
7	&	2	&	1	&	2	&	3	\\	\hline
8	&	1	&	3	&	1	&	2	\\	\hline
9	&	3	&	3	&	3	&	2	\\	\hline
10	&	2	&	1	&	3	&	3	\\	\hline
11	&	2	&	1	&	2	&	3	\\	\hline
12	&	3	&	1	&	1	&	1	\\	\hline
13	&	1	&	2	&	1	&	1	\\	\hline
14	&	2	&	3	&	2	&	2	\\	\hline
15	&	1	&	1	&	2	&	1	\\	\hline
16	&	3	&	2	&	3	&	2	\\	\hline
17	&	1	&	3	&	1	&	2	\\	\hline
18	&	3	&	1	&	2	&	1	\\	\hline
19	&	3	&	2	&	2	&	1	\\	\hline
20	&	1	&	3	&	1	&	2	\\	\hline
21	&	3	&	3	&	3	&	2	\\	\hline
22	&	3	&	1	&	3	&	3	\\	\hline
23	&	3	&	1	&	2	&	3	\\	\hline
24	&	3	&	2	&	2	&	1	\\	\hline
25	&	2	&	3	&	2	&	2	\\	\hline
  \end{tabular}
  \begin{tabular}{ |lllll| }
   
\hline
  & atr1 & atr2 & atr3 & classe \\ \hline
26	&	1	&	1	&	1	&	3	\\	\hline
27	&	1	&	1	&	1	&	1	\\	\hline
28	&	3	&	1	&	2	&	1	\\	\hline
29	&	3	&	2	&	1	&	1	\\	\hline
30	&	1	&	1	&	1	&	3	\\	\hline
31	&	3	&	3	&	2	&	2	\\	\hline
32	&	2	&	1	&	3	&	3	\\	\hline
33	&	2	&	3	&	1	&	2	\\	\hline
34	&	2	&	1	&	3	&	3	\\	\hline
35	&	1	&	3	&	2	&	2	\\	\hline
36	&	2	&	3	&	1	&	2	\\	\hline
37	&	1	&	2	&	3	&	1	\\	\hline
38	&	2	&	2	&	2	&	1	\\	\hline
39	&	1	&	1	&	2	&	1	\\	\hline
40	&	1	&	3	&	2	&	2	\\	\hline
41	&	2	&	2	&	1	&	1	\\	\hline
42	&	2	&	2	&	1	&	1	\\	\hline
43	&	3	&	3	&	3	&	2	\\	\hline
44	&	1	&	2	&	1	&	1	\\	\hline
45	&	3	&	3	&	2	&	2	\\	\hline
46	&	3	&	2	&	3	&	1	\\	\hline
47	&	2	&	2	&	3	&	1	\\	\hline
48	&	3	&	2	&	3	&	1	\\	\hline
49	&	3	&	3	&	3	&	2	\\	\hline
50	&	2	&	2	&	1	&	1	\\	\hline

\end{tabular}
\end{table}

A tabela \ref{tab:bdmd} é o resultado após a discretização de todos os atributos. Para cada base de dados será definido o número de faixas de acordo com a configuração inicial antes da execução. Nessa configuração do sistema o número de faixas serve para toda a base de dados e não para cada atributo, então nesse exemplo o valor de ${R=3}$ conforme figura \ref{fig:EFD_R_3}, onde ${R}$ é o número de faixas a ser dividido tanto no \textbf{atr1} como também no \textbf{atr2} e \textbf{atr3} possuem os valores conforme tabela \ref{tab:faixas}

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\centering
\caption{Valores das faixas com R=3 da Base de Dados Modelo}
\label{tab:faixas}
\begin{tabular}{lrrr}
\rowcolor[HTML]{C0C0C0} 
                                     & \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Faixa 1}} & \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Faixa 2}} & \multicolumn{1}{c}{\cellcolor[HTML]{C0C0C0}\textbf{Faixa 3}} \\
\rowcolor[HTML]{FFFFFF} 
{\color[HTML]{333333} \textbf{atr1}} & {[} 1.03 $\sim$1.44 {]}                                      & {]} 1.44 $\sim$1.74 {]}                                      & {]} 1.74 $\sim$2.09 {]}                                      \\
\rowcolor[HTML]{EFEFEF} 
{\color[HTML]{000000} \textbf{atr2}} & {\color[HTML]{000000} {[} 39.67 $\sim$67.66 {]}}             & {\color[HTML]{000000} {]} 67.66 $\sim$88.36 {]}}             & {\color[HTML]{000000} {]} 88.36 $\sim$108.36 {]}}            \\
\rowcolor[HTML]{FFFFFF} 
\textbf{atr3}                        & {[} 18.42 $\sim$19.82 {]}                                    & {]} 19.82 $\sim$21.61 {]}                                    & {]} 21.61 $\sim$23.09 {]}                                   
\end{tabular}
\end{table}

% Conforme cada valor discreto representando um intervalo, poderá o algoritmo está perdendo um pouco de informação, pois a discretização acaba generalizando a informação por agrupar os dados em intervalos representando-os de forma mais igual. Mas um fato a se levar em consideração é o número de faixas de valores, de uma variável discreta, pois se esse número for muito grande poderá acarretar ausência de generalização.


\subsection{Processo (II) - Algoritmos Supervisionados}\label{cap:ferramentas:ssec:algsuper}

Ao chegar nessa etapa, Processo (II) da figura \ref{fig:modeloresolucao}, já se tem uma base discretizada e clusters formados como visto na tabela \ref{tab:bdmd}. A partir desta etapa é feita a execução do algorimo de aprendizado supervisionado obtendo como saída um valor, em porcentagem, informando o grau de correlacionamento entre os atributos. Este valor irá compor uma matriz denominada de \textbf{Atributos Importantes}, cujo função é armazenar o resultado da execução dos algoritmos utilizando a técnica de correlação de atributos.

O algoritmo irá selecionar cluster por cluster, e serão percorridos todos os atributos destes clusters, onde a cada iteração um atributo será a classe da vez. Nesse exemplo, primeiramente o atributo \textbf{atr1} será classe, e os demais irão participar como entrada junto ao algoritmo, e verificar seu grau de importância entre eles. Depois o atributo \textbf{atr2} irá ser classe, e depois o \textbf{atr3}, fechando o ciclo de todos os atributos do cluster. Como visualizado na figura \ref{fig:tecnicamodelocomp} 
% \begin{figure}[h!]
%         \centering
%         \includegraphics[scale=0.7]{figs/tecnicamodeloComp.png}
%         \caption{Exemplo da técnica de correlação aplicada aos ${3 (três)}$ atributos, cada um sendo classe em determinada iteração } \label{fig:tecnicamodelocomp}
% \end{figure}

A cada aplicação do algoritmo supervisionado é armazanado para cada cluster ${c_i(atr)}$  os valores de relevância dos atributos representada por uma porcentagem de acerto. O algoritmo será executado o mesmo número de vezes do número de atributos existente na base de dados, pois a cada iteração um atributo se torna um atributo classe, consequentemente é gerado seu valor de relevância em porcentagem. Quanto maior sua porcentagem, mais bem correlacionado é o atributo em relação aos demais (figura \ref{fig:rotulacao}).Portanto esse atributo poderá resumir as características do problema, podendo ser considerado atributo mais relevante, e conseguinte escolhido como rótulo.

 \begin{figure}[h!]
    \centering
    \subfloat[Execução do Naive Bayes]{
        \includegraphics[scale=0.3]{figs/rotulacaoNB.png}
        \label{fig:rotulacao:rotNB} }
    \quad
    \subfloat[Execução do algorimo de Árvore de Decisão]{
        \includegraphics[scale=0.3]{figs/rotulacaoDecisionTree.png}
        \label{fig:rotulacao:rotDT} } 
    
    \caption{Resultado dos Algoritmos} \label{fig:rotulacao}
        %\includegraphics[scale=0.4]{figs/grafB.png}
        %\caption{Polinômio Superajustado} \label{grafB}
\end{figure}

Na figura \ref{fig:rotulacao:rotNB} mostra o resultado da execução do Naive Bayes trabalhando com a base modelo (tabela \ref{tab:bdmd}) exibindo os resultados em porcentagem de acerto de cada atributo em relação aos demais. O mesmo acontece com a figura \ref{fig:rotulacao:rotDT} onde é aplicado um algorimo de Árvore de Decisão - CART - exibindo o resultado de todas as taxas de acerto, em porcentagem, dos atributos de seus respectivos clusters.

Uma forma de eliminar uma possível ambiguidade entre os clusters foi adicionar na implementação uma variável  ${V}$. Essa variável é utilizada para seleção dos atributos rótulos de um clusters, caso aconteça dos rótulos se repetirem em clusters diferentes. Logo, todos os atributos que tiverem até uma diferença ${V}$ em relação ao atributo de maior taxa de acerto, expresso em porcentagem, serão escolhidos como rótulo. Isto posto, se o atributo de maior taxa de acerto possuir ${90\%}$, e o ${V=10\%}$  então todos outros atributos que tiverem valores a partir de ${80\%}$ são selecionados como rótulo do cluster.  

O valor da variável ${V}$ é subjetivo e irá ser arbitrado de acordo com os resultados em cada aplicação do algoritmo em um conjunto de dados. Nesse exemplo caso fosse utilizado a variância ${V=12}$ na matriz de atributos importantes representada pela figura \ref{fig:rotulacao:rotNB}, teriam os atributos, por clusters, ${r_{c_i}}$ : ${r_{c_1}=\{atr2\}}$, ${r_{c_2}=\{atr2\}}$, ${r_{c_3}=\{atr2\}}$.

O valor da variável V é subjetivo e irá ser arbitrado de acordo com os resultados
em cada aplicação do algoritmo em cima de um conjunto de dados. Nesse exemplo caso
fosse utilizado a variância V = 12 na matriz de atributos importantes representada pela
figura 11a, teriam os atributos, por clusters, rci : rc1 = {atr2}, rc2 = {atr2}, rc3 = {atr2}.


\subsection{Processo (III) - Rotulação} \label{cap:ferramentas:ssec:rotulacao}

No processo de rotulação os rótulos de cada cluster (${c_i}$) serão compostos conforme o  modelo \ref{eq:rotulo}. 
\begin{equation}\label{eq:rotulo}
r_{ci}=\{ (a_1,[p_1,q_1]),...,(a_{m^{(c_i)}}, ]p_{m^{(c_i)}},q_{m^{(c_i)}}]) \} 
\end{equation}

 Cada rótulo é composto pela tupla:  atributo de maior relevância e a faixa de valor desse atributo que mais se repete. Na figura \ref{fig:rotulacao} os rótulos em destaque são os que possuem maior valor, ademais, cada atributo que faz parte do rótulo possui um vetor de valores, de onde será escolhido a faixa de maior ocorrência. Uma vez calculado e definido a faixa, será determinado os limites inferiores (${p_{m^{(c_i)}}}$) e superiores (${q_{m^{(c_i)}}}$) de acordo com a tabela discretizada (exemplo \ref{tab:faixas}). 


Por exemplo, utilizando a Base Modelo, mais especificamente o cluster 1 ($c_1$), cujo resultado é apresentado na figura \ref{fig:rotulacao:rotNB}, o rótulo apresentado é o atributo  \textbf{atr2} com a \textbf{faixa 2}, faixa esta encontrada após cálculo dos elementos de maior ocorrência, conforme descrito no parágrafo acima. 

O rótulo apresentado ao final do processo terá a substituição do número da faixa pelos valores do intervalo conforme a tabela \ref{tab:faixas}. Os rótulos dos clusters descrito neste exemplo - conforme figura \ref{fig:rotulacao:rotNB} e figura  \ref{fig:rotulacao:rotDT} - aplicado na BD Modelo são:

\begin{itemize}[noitemsep]
            \item ${r_{c_1}=(atr2,]67.66, 88.36])}$;
            \item ${r_{c_2}=(atr2,]88.36, 108.36])}$ ;
            \item ${r_{c_3}=(atr2,[39.67, 67.66])}$;
            
\end{itemize}


Uma vez terminado o processo (III) de rotulação, o fluxo ${b}$ da figura \ref{fig:modeloresolucao}, só será executado caso seja necessário  testar outro algoritmo.


O algoritmo \ref{alg:rotulacao} exibe a rotina em forma de pseudocódigo para melhor entendimento.

\IncMargin{1em}
\begin{algorithm}[h]

\nl $Carrega\_valores\_auxiliares(V,R,TipoDiscretização)$\;
\nl $Carrega\_BD$\; 
\nl $Discretiza\_BD$\; 
\nl $Separa\_em\_clusters\_de\_acordo\_com\_classificação\_BD$\; 
\nl \While{existir clusters}{
 \nl \While{existir atributos}{ 
      \nl $atributo\_classe$=$seleciona\_nova\_classe(atributos)$ \; 
      \nl $Aplica\_algoritmo\_supervisionado(atributo\_classe,atributos\_naoClasse)$\;
      \nl $Calcula\_matriz\_de\_porcentagem\_de\_acertos$\; 
      } 
    \nl \If{V!=0}{
        \nl $Carrega\_atributos\_importantes\_considerando\_V$\;
        }
    \nl $Associa\_valores\_aos\_intervalos$\; 
 }
 \nl $Exibe\_rótulos\_todos\_clusters$\; 
 \caption{Rotina de Rotulação}\label{alg:rotulacao}
 
\end{algorithm}
\DecMargin{1em}
        
